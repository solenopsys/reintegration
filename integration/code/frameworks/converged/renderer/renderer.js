var w5=!!globalThis.CDATASection?.toString?.().match(/^\s*function\s+CDATASection\s*\(\s*\)\s*\{\s*\[native code\]\s*\}\s*$/),F5=()=>{return!w5},W6=F5;var b1=Symbol("Cached"),H1=Symbol("Observable"),J0=Symbol("Observable.Boolean"),x1=Symbol("Observable.Frozen"),I1=Symbol("Observable.Readable"),L1=Symbol("Observable.Writable"),P1=Symbol("Store"),Y0=Symbol("Store.Keys"),C1=Symbol("Store.Observable"),p1=Symbol("Store.Target"),d1=Symbol("Store.Values"),M0=Symbol("Store.Untracked"),o=Symbol("Suspense"),J1=Symbol("Uncached"),W1=Symbol("Untracked"),Q1=Symbol("Untracked.Unwrapped");var _2=(J)=>{return V1(J)?J:[J]},E2=(J)=>{if(J instanceof Error)return J;if(typeof J==="string")return new Error(J);return new Error("Unknown error")},{is:X1}=Object,{isArray:V1}=Array,k2=(J,Q)=>{if(J.length!==Q.length)return!1;for(let X=0,Z=J.length;X<Z;X++){const G=J[X],q=Q[X];if(!X1(G,q))return!1}return!0},j=(J)=>{return typeof J==="function"},Q0=(J)=>{return J!==null&&typeof J==="object"},S2=(J)=>{return typeof J==="symbol"},i1=()=>{return},x0=()=>{return!1};var V5=function(){if(arguments.length)throw new Error("A readonly Observable can not be updated");else return this},U5=function(){if(arguments.length)throw new Error("A readonly Observable can not be updated");else return this.get()},z5=function(J){if(arguments.length)if(j(J))return this.update(J);else return this.set(J);else return this.get()},O=(J)=>{const Q=V5.bind(J);return Q[H1]=!0,Q[x1]=!0,Q},E=(J)=>{const Q=U5.bind(J);return Q[H1]=!0,Q[I1]=J,Q},y2=(J)=>{const Q=z5.bind(J);return Q[H1]=!0,Q[L1]=J,Q};var o0=0,v1=1,R1=2,f1=3,P0=O(!1),m2=O(!0),u1=new Proxy({},new Proxy({},{get(){throw new Error("Unavailable value")}})),C0=function(){};var j0=(J,Q)=>{if(J instanceof Array)for(let X=0,Z=J.length;X<Z;X++)Q(J[X]);else if(J)Q(J)},X0=(J,Q)=>{if(J instanceof Array)for(let X=J.length-1;X>=0;X--)Q(J[X]);else if(J)Q(J)},$1=(J,Q,X)=>{const Z=J[Q];if(Z instanceof Array)Z.push(X);else if(Z)J[Q]=[Z,X];else J[Q]=X},r=(J,Q,X)=>{const Z=J[Q];if(Z instanceof Set)Z.add(X);else if(Z){if(X!==Z){const G=new Set;G.add(Z),G.add(X),J[Q]=G}}else J[Q]=X},a=(J,Q,X)=>{const Z=J[Q];if(Z instanceof Set)Z.delete(X);else if(Z===X)J[Q]=void 0},O1=(J,Q)=>{if(J instanceof Set)for(let X of J)Q(X);else if(J)Q(J)};var D5=(J)=>J.call(J),l0=(J)=>J.dispose(!0);class h2{parent;context;disposed=!1;cleanups=void 0;errorHandler=void 0;contexts=void 0;observers=void 0;roots=void 0;suspenses=void 0;catch(J,Q){const{errorHandler:X}=this;if(X)return X(J),!0;else{if(this.parent?.catch(J,!0))return!0;if(Q)return!1;throw J}}dispose(J){X0(this.contexts,l0),X0(this.observers,l0),X0(this.suspenses,l0),X0(this.cleanups,D5),this.cleanups=void 0,this.disposed=J,this.errorHandler=void 0,this.observers=void 0,this.suspenses=void 0}get(J){return this.context?.[J]}wrap(J,Q,X){const Z=x,G=Z1;r0(Q),c1(X);try{return J()}catch(q){return this.catch(E2(q),!1),u1}finally{r0(Z),c1(G)}}}var w1=h2;class b2 extends w1{constructor(){super(...arguments)}parent;context={}}var p2=b2;var U1,a0=new p2,Z1,x=a0,s0=(J)=>U1=J,c1=(J)=>Z1=J,r0=(J)=>x=J;var A0=0,d2=i1,T5=async(J)=>{if(!A0)s0(new Promise((Q)=>d2=Q));try{return A0+=1,await J()}finally{if(A0-=1,!A0)s0(void 0),d2()}},t0=T5;var Y5=(J)=>{return j(J)&&J0 in J},N0=Y5;var M5=(J)=>{return j(J)&&((x1 in J)||!!J[I1]?.parent?.disposed)},z1=M5;var x5=(J)=>{return j(J)&&((W1 in J)||(Q1 in J))},n1=x5;class i2{waiting=[];counter=0;locked=!1;flush=()=>{if(this.locked)return;if(this.counter)return;if(!this.waiting.length)return;try{this.locked=!0;while(!0){const J=this.waiting;if(!J.length)break;this.waiting=[];for(let Q=0,X=J.length;Q<X;Q++)J[Q].update()}}finally{this.locked=!1}};wrap=(J)=>{this.counter+=1,J(),this.counter-=1,this.flush()};schedule=(J)=>{this.waiting.push(J)}}var g1=new i2;class v2{parent;value;equals;observers=new Set;constructor(J,Q,X){if(this.value=J,X)this.parent=X;if(Q?.equals!==void 0)this.equals=Q.equals||x0}get(){if(!this.parent?.disposed)this.parent?.update(),Z1?.observables.link(this);return this.value}set(J){const Q=this.equals||X1;if(!(this.value===C0||!Q(J,this.value)))return J;return this.value=J,g1.counter+=1,this.stale(f1),g1.counter-=1,g1.flush(),J}stale(J){for(let Q of this.observers)if(Q.status!==v1||Q.observables.has(this))if(Q.sync)Q.status=Math.max(Q.status,J),g1.schedule(Q);else Q.stale(J)}update(J){const Q=J(this.value);return this.set(Q)}}var R=v2;class e0{observer;observables;observablesIndex;constructor(J){this.observer=J,this.observables=[],this.observablesIndex=0}dispose(J){if(J){const{observer:Q,observables:X}=this;for(let Z=0;Z<X.length;Z++)X[Z].observers.delete(Q)}this.observablesIndex=0}postdispose(){const{observer:J,observables:Q,observablesIndex:X}=this,Z=Q.length;if(X<Z){for(let G=X;G<Z;G++)Q[G].observers.delete(J);Q.length=X}}empty(){return!this.observables.length}has(J){const Q=this.observables.indexOf(J);return Q>=0&&Q<this.observablesIndex}link(J){const{observer:Q,observables:X,observablesIndex:Z}=this,G=X.length;if(G>0){if(X[Z]===J){this.observablesIndex+=1;return}const q=X.indexOf(J);if(q>=0&&q<Z)return;if(Z<G-1)this.postdispose();else if(Z===G-1)X[Z].observers.delete(Q)}if(J.observers.add(Q),X[this.observablesIndex++]=J,Z===128)Q.observables=new u2(Q,X)}update(){const{observables:J}=this;for(let Q=0,X=J.length;Q<X;Q++)J[Q].parent?.update()}}class u2{observer;observables;constructor(J,Q){this.observer=J,this.observables=new Set(Q)}dispose(J){for(let Q of this.observables)Q.observers.delete(this.observer)}postdispose(){return}empty(){return!this.observables.size}has(J){return this.observables.has(J)}link(J){const{observer:Q,observables:X}=this,Z=X.size;J.observers.add(Q);const G=X.size;if(Z===G)return;X.add(J)}update(){for(let J of this.observables)J.parent?.update()}}class c2 extends w1{parent=x;context=x.context;status=f1;observables;sync;constructor(){super();if(this.observables=new e0(this),x!==a0)$1(this.parent,"observers",this)}dispose(J){this.observables.dispose(J),super.dispose(J)}refresh(J){this.dispose(!1),this.status=v1;try{return this.wrap(J,this,this)}finally{this.observables.postdispose()}}run(){throw new Error("Abstract method")}stale(J){throw new Error("Abstract method")}update(){if(this.disposed)return;if(this.status===R1)this.observables.update();if(this.status===f1)if(this.status=v1,this.run(),this.status===v1)this.status=o0;else this.update();else this.status=o0}}var B0=c2;class n2 extends B0{fn;observable;sync;constructor(J,Q){super();if(this.fn=J,this.observable=new R(C0,Q,this),Q?.sync===!0)this.sync=!0,this.update()}run(){const J=super.refresh(this.fn);if(!this.disposed&&this.observables.empty())this.disposed=!0;if(J!==u1)this.observable.set(J)}stale(J){const Q=this.status;if(Q>=J)return;if(this.status=J,Q===R1)return;this.observable.stale(R1)}}var o2=n2;var P5=(J,Q)=>{if(z1(J))return J;else if(n1(J))return O(J());else{const X=new o2(J,Q);return E(X.observable)}},L=P5;var C5=(J)=>{if(j(J))if(z1(J)||n1(J))return!!J();else if(N0(J))return J;else{const Q=L(()=>!!J());return Q[J0]=!0,Q}else return!!J},_1=C5;var j5=(J)=>{$1(x,"cleanups",J)},k=j5;class l2 extends w1{parent=x;context;constructor(J){super();this.context={...x.context,...J},$1(this.parent,"contexts",this)}wrap(J){return super.wrap(J,this,void 0)}}var r2=l2;var A5=function(J,Q){if(S2(J))return x.context[J];else return new r2(J).wrap(Q||i1)},S=A5;var N5=()=>{const J=new R(!1);return k(()=>J.set(!0)),E(J)},J2=N5;class a2{waiting=[];locked=!1;queued=!1;flush=()=>{if(this.locked)return;if(!this.waiting.length)return;try{this.locked=!0;while(!0){const J=this.waiting;if(!J.length)break;this.waiting=[];for(let Q=0,X=J.length;Q<X;Q++)J[Q].update()}}finally{this.locked=!1}};queue=()=>{if(this.queued)return;this.queued=!0,this.resolve()};resolve=()=>{queueMicrotask(()=>{queueMicrotask(()=>{if(U1)U1.finally(this.resolve);else this.queued=!1,this.flush()})})};schedule=(J)=>{this.waiting.push(J),this.queue()}}var E1=new a2;class s2 extends B0{fn;suspense;init;sync;constructor(J,Q){super();if(this.fn=J,Q?.suspense!==!1){const X=this.get(o);if(X)this.suspense=X}if(Q?.sync===!0)this.sync=!0;if(Q?.sync==="init")this.init=!0,this.update();else this.schedule()}run(){const J=super.refresh(this.fn);if(j(J))$1(this,"cleanups",J)}schedule(){if(this.suspense?.suspended)return;if(this.sync)this.update();else E1.schedule(this)}stale(J){const Q=this.status;if(Q>=J)return;if(this.status=J,!this.sync||Q!==2&&Q!==3)this.schedule()}update(){if(this.suspense?.suspended)return;super.update()}}var L0=s2;var B5=(J,Q)=>{const X=new L0(J,Q);return()=>X.dispose(!0)},D1=B5;var Z0=function(J){if(j(J))if(Q1 in J)return Z0(J());else if(W1 in J)return O(Z0(J()));else if(H1 in J)return J;else return L(()=>Z0(J()));if(J instanceof Array){const Q=new Array(J.length);for(let X=0,Z=Q.length;X<Z;X++)Q[X]=Z0(J[X]);return Q}else return J},N=Z0;class t2 extends w1{parent=x;context=x.context;registered;constructor(J){super();if(J){if(this.get(o))this.registered=!0,r(this.parent,"roots",this)}}dispose(J){if(this.registered)a(this.parent,"roots",this);super.dispose(J)}wrap(J){const Q=()=>this.dispose(!0),X=()=>J(Q);return super.wrap(X,this,void 0)}}var o1=t2;var L5=O(-1);class e2 extends o1{constructor(){super(...arguments)}bool;index;result}class J4{parent=x;suspense=x.get(o);fn;fnWithIndex;cache=new Map;bool=!1;prevCount=0;reuseCount=0;nextCount=0;constructor(J){if(this.fn=J,this.fnWithIndex=J.length>1,this.suspense)r(this.parent,"roots",this.roots)}cleanup=()=>{if(!this.prevCount)return;if(this.prevCount===this.reuseCount)return;const{cache:J,bool:Q}=this;if(!J.size)return;if(this.nextCount)J.forEach((X,Z)=>{if(X.bool===Q)return;X.dispose(!0),J.delete(Z)});else this.cache.forEach((X)=>{X.dispose(!0)}),this.cache=new Map};dispose=()=>{if(this.suspense)a(this.parent,"roots",this.roots);this.prevCount=this.cache.size,this.reuseCount=0,this.nextCount=0,this.cleanup()};before=()=>{this.bool=!this.bool,this.reuseCount=0,this.nextCount=0};after=(J)=>{this.nextCount=J.length,this.cleanup(),this.prevCount=this.nextCount,this.reuseCount=0};map=(J)=>{this.before();const{cache:Q,bool:X,fn:Z,fnWithIndex:G}=this,q=new Array(J.length);let K=!0,H=!0,I=0;for(let $=0,z=J.length;$<z;$++){const W=J[$],U=Q.get(W);if(U&&U.bool!==X)H=!1,I+=1,U.bool=X,U.index?.set($),q[$]=U.result;else{K=!1;const D=new e2(!1);if(U)k(()=>D.dispose(!0));D.wrap(()=>{let F=L5;if(G)D.index=new R($),F=E(D.index);const V=q[$]=N(Z(W,F));if(D.bool=X,D.result=V,!U)Q.set(W,D)})}}if(this.reuseCount=I,this.after(J),K)q[b1]=!0;if(H)q[J1]=!0;return q};roots=()=>{return Array.from(this.cache.values())}}var Q4=J4;var R5=(J)=>{return j(J)&&H1 in J},k1=R5;var f5=function(J,Q=!0){if((Q?j:k1)(J))return J();else return J},s=f5;class X4 extends w1{parent=x;context={...x.context,[o]:this};observable;suspended;constructor(){super();$1(this.parent,"suspenses",this),this.suspended=x.get(o)?.suspended||0}toggle(J){if(!this.suspended&&!J)return;const Q=this.suspended,X=Q+(J?1:-1);if(this.suspended=X,!!Q===!!X)return;this.observable?.set(!!X);const Z=(H)=>{j0(H.contexts,Z),j0(H.observers,G),j0(H.suspenses,K),O1(H.roots,q)},G=(H)=>{if(H instanceof L0){if(H.status===R1||H.status===f1)if(H.init)H.update();else H.schedule()}Z(H)},q=(H)=>{if(j(H))H().forEach(Z);else Z(H)},K=(H)=>{H.toggle(J)};Z(this)}wrap(J){return super.wrap(J,this,void 0)}}var Z4=X4;var O5=(J,Q)=>{const X=new Z4,Z=_1(J);return D1(()=>X.toggle(s(Z)),{sync:!0}),X.wrap(Q)},G0=O5;var g5=O(-1);class G4 extends o1{constructor(){super(...arguments)}index;value;suspended;result}class q4{parent=x;suspense=x.get(o);fn;fnWithIndex;cache=new Map;pool=[];poolMaxSize=0;pooled;constructor(J,Q){if(this.fn=J,this.fnWithIndex=J.length>1,this.pooled=Q,this.suspense)r(this.parent,"roots",this.roots)}cleanup=()=>{let J=0,Q=Math.max(0,this.pooled?this.poolMaxSize-this.pool.length:0);this.cache.forEach((X)=>{if(Q>0&&J++<Q)X.suspended?.set(!0),this.pool.push(X);else X.dispose(!0)})};dispose=()=>{if(this.suspense)a(this.parent,"roots",this.roots);this.cache.forEach((J)=>{J.dispose(!0)}),this.pool.forEach((J)=>{J.dispose(!0)})};map=(J)=>{const{cache:Q,fn:X,fnWithIndex:Z}=this,G=new Map,q=new Array(J.length),K=this.pool,H=this.pooled;let I=!0,$=!0,z=[];if(Q.size)for(let W=0,U=J.length;W<U;W++){const D=J[W],F=Q.get(D);if(F)$=!1,Q.delete(D),G.set(D,F),F.index?.set(W),q[W]=F.result;else z.push(W)}else z=new Array(q.length);J:for(let W=0,U=z.length;W<U;W++){const D=z[W]||W,F=J[D],V=G.has(F);if(!V)for(let[T,Y]of Q.entries()){Q.delete(T),G.set(F,Y),Y.index?.set(D),Y.value?.set(F),q[D]=Y.result;continue J}I=!1;let w;if(H&&K.length)w=K.pop(),w.index?.set(D),w.value?.set(F),w.suspended?.set(!1),q[D]=w.result;else w=new G4(!1),w.wrap(()=>{let T=g5;if(Z)w.index=new R(D),T=E(w.index);const Y=w.value=new R(F),C=H?new R(!1):void 0,A=L(()=>s(Y.get())),B=q[D]=C?G0(()=>C.get(),()=>N(X(A,T))):N(X(A,T));w.value=Y,w.result=B,w.suspended=C});if(V)k(()=>w.dispose(!0));else G.set(F,w)}if(this.poolMaxSize=Math.max(this.poolMaxSize,q.length),this.cleanup(),this.cache=G,I)q[b1]=!0;if($)q[J1]=!0;return q};roots=()=>{return[...this.cache.values(),...this.pool.values()]}}var K4=q4;var _5=(J)=>{return Q0(J)&&P1 in J},d=_5;var E5=function(J){if(j(J)){const Q=Z1;if(Q)try{return c1(void 0),J()}finally{c1(Q)}else return J()}else return J},y=E5;var k5=function(J,Q,X=[],Z){if(V1(J)&&!d(J)){const G=!!Z?.unkeyed;return O(y(()=>{if(J.length)return J.map((q,K)=>{return N(Q(G&&!k1(q)?O(q):q,K))});else return N(X)}))}else{const{dispose:G,map:q}=Z?.unkeyed?new K4(Q,!!Z.pooled):new Q4(Q);k(G);const K=L(()=>{return s(J)??[]},{equals:(H,I)=>{return!!H&&!!I&&!H.length&&!I.length&&!d(H)&&!d(I)}});return L(()=>{const H=K();if(d(H))H[d1];return y(()=>{const I=q(H);return I?.length?I:N(X)})},{equals:(H,I)=>{return V1(H)&&!!H[b1]&&V1(I)&&k2(H,I)}})}},Q2=k5;var S5=(J)=>{return y(J),J},R0=S5;var y5=function(J,Q,X){if(j(J)&&!z1(J)&&!n1(J)){if(N0(J))return L(()=>N(X2(J(),Q,X)));const G=R0(L(()=>X2(J(),Q,X)));if(z1(G))return O(N(G()));else return L(()=>N(s(G)))}else{const G=X2(s(J),Q,X);return O(N(G))}},X2=(J,Q,X)=>{for(let Z=0,G=Q.length;Z<G;Z++){const q=Q[Z];if(q.length===1)return q[0];if(X1(q[0],J))return q[1]}return X},q0=y5;var m5=(J,Q,X)=>{const Z=_1(J);return q0(Z,[[!0,Q],[X]])},j1=m5;var h5=()=>{return!!U1||E1.queued||E1.locked||g1.locked},K0=h5;var b5=function(J,Q){return y2(new R(J,Q))},H0=b5;var p5=(J)=>{return j(J)&&L1 in J},H4=p5;var d5=(J)=>{if(j(J))return J[I1]||J[L1]||u1;else return J},I4=d5;var i5=(J)=>{if(H4(J))return E(I4(J));else return J},Z2=i5;var v5=(J)=>{return new o1(!0).wrap(J)},G2=v5;class W4 extends Map{constructor(){super(...arguments)}disposed=!1}class $4 extends R{constructor(){super(...arguments)}count=1;selecteds;source;call(){if(this.selecteds.disposed)return;if(this.count-=1,this.count)return;this.selecteds.delete(this.source)}}var u5=(J)=>{if(J=R0(L(J)),z1(J)){const G=y(J);return(q)=>{return q===G?m2:P0}}let Q=new W4,X=y(J);return D1(()=>{const G=X,q=J();if(X1(G,q))return;X=q,Q.get(G)?.set(!1),Q.get(q)?.set(!0)},{suspense:!1,sync:!0}),k(()=>{Q.disposed=!0}),(G)=>{let q=Q.get(G);if(q)q.count+=1;else q=new $4(G===X),q.selecteds=Q,q.source=G,Q.set(G,q);return k(q),E(q)}},q2=u5;class T1 extends Map{constructor(){super(...arguments)}insert(J,Q){return super.set(J,Q),Q}}class w0{count=0;listen(){this.count+=1,k(this)}call(){if(this.count-=1,this.count)return;this.dispose()}dispose(){}}class V4 extends w0{J;Q;constructor(J,Q){super();this.parent=J;this.observable=Q}dispose(){this.parent.keys=void 0}}class U4 extends w0{J;Q;constructor(J,Q){super();this.parent=J;this.observable=Q}dispose(){this.parent.values=void 0}}class z4 extends w0{J;Q;X;constructor(J,Q,X){super();this.parent=J;this.key=Q;this.observable=X}dispose(){this.parent.has?.delete(this.key)}}class D4 extends w0{J;Q;X;Z;constructor(J,Q,X,Z){super();this.parent=J;this.key=Q;this.observable=X;this.node=Z}dispose(){this.parent.properties?.delete(this.key)}}var i={active:0,listeners:new Set,nodes:new Set,prepare:()=>{const{listeners:J,nodes:Q}=i,X=new Set,Z=(G)=>{if(X.has(G))return;X.add(G),O1(G.parents,Z),O1(G.listenersRegular,(q)=>{J.add(q)})};return Q.forEach(Z),()=>{J.forEach((G)=>{G()})}},register:(J)=>{i.nodes.add(J),G1.schedule()},reset:()=>{i.listeners=new Set,i.nodes=new Set}},f={active:0,nodes:new Map,prepare:()=>{const{nodes:J}=f;return()=>{J.forEach((Q,X)=>{const Z=Array.from(Q);O1(X.listenersRoots,(G)=>{G(Z)})})}},register:(J,Q)=>{const X=f.nodes.get(J)||new Set;X.add(Q),f.nodes.set(J,X),G1.schedule()},registerWith:(J,Q,X)=>{if(!Q.parents){const Z=J?.store||y(()=>Q.store[X]);f.register(Q,Z)}else{const Z=new Set,G=(q)=>{if(Z.has(q))return;Z.add(q),O1(q.parents,(K)=>{if(!K.parents)f.register(K,q.store);G(K)})};G(J||Q)}},reset:()=>{f.nodes=new Map}},G1={active:!1,flush:()=>{const J=i.prepare(),Q=f.prepare();G1.reset(),J(),Q()},flushIfNotBatching:()=>{if(K0())if(U1)U1.finally(G1.flushIfNotBatching);else setTimeout(G1.flushIfNotBatching,0);else G1.flush()},reset:()=>{G1.active=!1,i.reset(),f.reset()},schedule:()=>{if(G1.active)return;G1.active=!0,queueMicrotask(G1.flushIfNotBatching)}},l1=new WeakMap,c5=new Set([P1,Y0,C1,p1,d1]),n5=new Set(["__proto__","__defineGetter__","__defineSetter__","__lookupGetter__","__lookupSetter__","prototype","constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toSource","toString","valueOf"]),o5={get:(J,Q)=>{if(c5.has(Q)){if(Q===P1)return!0;if(Q===p1)return J;if(Q===Y0){if(I0()){const I=F1(J);I.keys||=w4(I),I.keys.listen(),I.keys.observable.get()}return}if(Q===d1){if(I0()){const I=F1(J);I.values||=r5(I),I.values.listen(),I.values.observable.get()}return}if(Q===C1)return(I)=>{I=typeof I==="number"?String(I):I;const $=F1(J),z=$.getters?.get(I);if(z)return z.bind($.store);$.properties||=new T1;const W=J[I],U=$.properties.get(I)||$.properties.insert(I,F4($,I,W)),D=$.equals?{equals:$.equals}:void 0;return U.observable||=$0($,W,D),E(U.observable)}}if(n5.has(Q))return J[Q];const X=F1(J),Z=X.getters?.get(Q),G=Z||J[Q];X.properties||=new T1;const q=I0(),K=W0(G),H=q||K?X.properties.get(Q)||X.properties.insert(Q,F4(X,Q,G)):void 0;if(H?.node)r(H.node,"parents",X);if(H&&q){const I=X.equals?{equals:X.equals}:void 0;H.listen(),H.observable||=$0(X,G,I),H.observable.get()}if(Z)return Z.call(X.store);else{if(typeof G==="function"&&G===Array.prototype[Q])return function(){return G.apply(X.store,arguments)};return H?.node?.store||G}},set:(J,Q,X)=>{X=A1(X);const Z=F1(J),G=Z.setters?.get(Q);if(G)G.call(Z.store,X);else{const q=J[Q],K=!!q||Q in J,H=Z.equals||X1;if(K&&H(X,q)&&(Q!=="length"||!Array.isArray(J)))return!0;if(J[Q]=X,Z.values?.observable.set(0),!K)Z.keys?.observable.set(0),Z.has?.get(Q)?.observable.set(!0);const I=Z.properties?.get(Q);if(I?.node)a(I.node,"parents",Z);if(I)I.observable?.set(X),I.node=W0(X)?l1.get(X)||f0(X,Z):void 0;if(I?.node)r(I.node,"parents",Z);if(f.active)f.registerWith(I?.node,Z,Q);if(i.active)i.register(Z)}return!0},deleteProperty:(J,Q)=>{if(!(Q in J))return!0;if(!Reflect.deleteProperty(J,Q))return!1;const G=F1(J);G.keys?.observable.set(0),G.values?.observable.set(0),G.has?.get(Q)?.observable.set(!1);const q=G.properties?.get(Q);if(f.active)f.registerWith(q?.node,G,Q);if(q?.node)a(q.node,"parents",G);if(q)q.observable?.set(void 0),q.node=void 0;if(i.active)i.register(G);return!0},defineProperty:(J,Q,X)=>{const Z=F1(J),G=Z.equals||X1,q=Q in J,K=Reflect.getOwnPropertyDescriptor(J,Q);if("value"in X&&d(X.value))X={...X,value:A1(X.value)};if(K&&J3(K,X,G))return!0;if(!Reflect.defineProperty(J,Q,X))return!1;if(!X.get)Z.getters?.delete(Q);else if(X.get)Z.getters||=new T1,Z.getters.set(Q,X.get);if(!X.set)Z.setters?.delete(Q);else if(X.set)Z.setters||=new T1,Z.setters.set(Q,X.set);if(q!==!!X.enumerable)Z.keys?.observable.set(0);Z.has?.get(Q)?.observable.set(!0);const I=Z.properties?.get(Q);if(f.active)f.registerWith(I?.node,Z,Q);if(I?.node)a(I.node,"parents",Z);if(I)if("get"in X)I.observable?.set(X.get),I.node=void 0;else{const $=X.value;I.observable?.set($),I.node=W0($)?l1.get($)||f0($,Z):void 0}if(I?.node)r(I.node,"parents",Z);if(f.active)f.registerWith(I?.node,Z,Q);if(i.active)i.register(Z);return!0},has:(J,Q)=>{if(Q===P1)return!0;if(Q===p1)return!0;const X=Q in J;if(I0()){const Z=F1(J);Z.has||=new T1;const G=Z.has.get(Q)||Z.has.insert(Q,a5(Z,Q,X));G.listen(),G.observable.get()}return X},ownKeys:(J)=>{const Q=Reflect.ownKeys(J);if(I0()){const X=F1(J);X.keys||=w4(X),X.keys.listen(),X.keys.observable.get()}return Q}},l5={has:(J,Q)=>{if(Q===M0)return!0;return Q in J}},f0=(J,Q,X)=>{const Z=new Proxy(J,o5),G=s5(J),q={parents:Q,store:Z};if(G){const{getters:K,setters:H}=G;if(K)q.getters=K;if(H)q.setters=H}if(X===!1)q.equals=x0;else if(X)q.equals=X;else if(Q?.equals)q.equals=Q.equals;return l1.set(J,q),q},F1=(J)=>{const Q=l1.get(J);if(!Q)throw new Error("Impossible");return Q},T4=(J)=>{return F1(A1(J))},w4=(J)=>{const Q=$0(J,0,{equals:!1});return new V4(J,Q)},r5=(J)=>{const Q=$0(J,0,{equals:!1});return new U4(J,Q)},a5=(J,Q,X)=>{const Z=$0(J,X);return new z4(J,Q,Z)},$0=(J,Q,X)=>{return new R(Q,X)},F4=(J,Q,X)=>{const G=W0(X)?l1.get(X)||f0(X,J):void 0,q=new D4(J,Q,void 0,G);return J.properties||=new T1,J.properties.set(Q,q),q},s5=(J)=>{if(V1(J))return;let Q,X;const Z=Object.keys(J);for(let G=0,q=Z.length;G<q;G++){const K=Z[G],H=Object.getOwnPropertyDescriptor(J,K);if(!H)continue;const{get:I,set:$}=H;if(I)Q||=new T1,Q.set(K,I);if($)X||=new T1,X.set(K,$)}if(!Q&&!X)return;return{getters:Q,setters:X}},t5=(J,Q)=>{if(d(J))return J;return(l1.get(J)||f0(J,void 0,Q?.equals)).store},A1=(J)=>{if(d(J))return J[p1];return J},e5=(J)=>{if(!Q0(J))return J;if(Y4(J))return J;return new Proxy(J,l5)},J3=(J,Q,X)=>{return!!J.configurable===!!Q.configurable&&!!J.enumerable===!!Q.enumerable&&!!J.writable===!!Q.writable&&X(J.value,Q.value)&&J.get===Q.get&&J.set===Q.set},I0=()=>{return!!Z1},W0=(J)=>{if(J===null||typeof J!=="object")return!1;if(P1 in J)return!0;if(M0 in J)return!1;if(V1(J))return!0;const Q=Object.getPrototypeOf(J);if(Q===null)return!0;return Object.getPrototypeOf(Q)===null},Y4=(J)=>{if(J===null||typeof J!=="object")return!1;return M0 in J},r1=(J,Q)=>{if(!Q0(J))return J;if(Y4(J))return J;return t5(J,Q)};r1.on=(J,Q)=>{const X=d(J)?[J]:_2(J),Z=X.filter(j),G=X.filter(d).map(T4);i.active+=1;const q=Z.map((K)=>{let H=!1;return D1(()=>{if(H)i.listeners.add(Q),G1.schedule();H=!0,K()},{suspense:!1,sync:!0})});return G.forEach((K)=>{r(K,"listenersRegular",Q)}),()=>{i.active-=1,q.forEach((K)=>{K()}),G.forEach((K)=>{a(K,"listenersRegular",Q)})}};r1._onRoots=(J,Q)=>{if(!d(J))return i1;const X=T4(J);if(X.parents)throw new Error("Only top-level stores are supported");return f.active+=1,r(X,"listenersRoots",Q),()=>{f.active-=1,a(X,"listenersRoots",Q)}};r1.reconcile=(()=>{const J=(G)=>{if(V1(G))return 1;if(W0(G))return 2;return 0},Q=(G,q)=>{const K=A1(G),H=A1(q);X(G,q);const I=J(K),$=J(H);if(I===1||$===1)G.length=q.length;return G},X=(G,q)=>{const K=A1(G),H=A1(q),I=Object.keys(K),$=Object.keys(H);for(let z=0,W=$.length;z<W;z++){const U=$[z],D=K[U],F=H[U];if(!X1(D,F)){const V=J(D),w=J(F);if(V&&V===w){if(X(G[U],F),V===1)G[U].length=F.length}else G[U]=F}else if(D===void 0&&!(U in K))G[U]=void 0}for(let z=0,W=I.length;z<W;z++){const U=I[z];if(!(U in H))delete G[U]}return G};return(G,q)=>{return y(()=>{return Q(G,q)})}})();r1.untrack=(J)=>{return e5(J)};r1.unwrap=(J)=>{return A1(J)};var K2=r1;var Q3=()=>{const J=x.get(o);if(!J)return P0;const Q=J.observable||=new R(!!J.suspended);return E(Q)},H2=Q3;var X3=()=>{E1.flush()},I2=X3;var Z3=(J,Q)=>{const X=H0();return L(()=>{const Z=X();if(Z)return N(Q({error:Z,reset:()=>X(void 0)}));else return x.errorHandler=X,N(J)})},W2=Z3;var G3=function(J){const Q=j(J)?(...X)=>y(()=>J(...X)):()=>J;return Q[W1]=!0,Q},$2=G3;var q3=()=>{const J=x,Q=Z1;return(X)=>{return J.wrap(()=>X(),J,Q)}},F0=q3;var m=L;var v=y;var O0=new WeakMap,V0={},w2=Symbol("Suspense"),U0=Symbol("Suspense.Collector"),g0=Symbol("Template.Accessor"),_0={};var K3=(J)=>{return J[Q1]=!0,J},a1=K3;var F2=document.createComment.bind(document,""),E0=document.createElement.bind(document),M4=document.createElementNS.bind(document,"http://www.w3.org/2000/svg"),S1=document.createTextNode.bind(document);var{assign:t}=Object,Y1=(J)=>{return h(J)?J:[J]},x4=(J)=>{if(H3(J))return J;if(p(J))return new Error(J);return new Error("Unknown error")},P4=(J)=>{for(let Q=0,X=J.length;Q<X;Q++){if(!h(J[Q]))continue;return J.flat(Infinity)}return J},C4=(()=>{const J=Array.prototype.indexOf;return(Q,X)=>{return J.call(Q,X)}})(),{isArray:h}=Array,j4=(J)=>{return typeof J==="boolean"},A4=(J)=>{return P(J)&&Q1 in J},H3=(J)=>{return J instanceof Error};var P=(J)=>{return typeof J==="function"},N1=(J)=>{return!((W1 in J)||(Q1 in J)||(x1 in J)||J[I1]?.parent?.disposed)},b=(J)=>{return J===null||J===void 0},N4=(J)=>{return J instanceof Node},B4=(J)=>{return typeof J==="object"&&J!==null},L4=(J)=>{return J instanceof Promise},p=(J)=>{return typeof J==="string"},y1=(J)=>{return!!J.isSVG},R4=(()=>{const J=/^(t(ext$|s)|s[vwy]|g)|^set|tad|ker|p(at|s)|s(to|c$|ca|k)|r(ec|cl)|ew|us|f($|e|s)|cu|n[ei]|l[ty]|[GOP]/,Q={};return(X)=>{const Z=Q[X];return Z!==void 0?Z:Q[X]=!X.includes("-")&&J.test(X)}})(),f4=(J)=>{return P(J)&&g0 in J},O4=(J)=>{return!!J},g4=(J)=>{return J===null||J===void 0||typeof J==="boolean"||typeof J==="symbol"};var _4=(J)=>{let Q=!1,X;return()=>{if(!Q)Q=!0,X=J();return X}};var q1=k;var B1=D1;var s1=k1;var I3=function(J,Q,X){const Z=X!==!1&&Q!==!1?P:s1,G=(q)=>Z(q)?q():q;if(h(J)){const q=J.map(G);if(P(Q))return Q.apply(void 0,q);else return q}else{const q=G(J);if(P(Q))return Q(q);else return q}},M1=I3;var M=s;var W3=function(J,Q,X,Z){return B1(()=>{const G=M(X,!1);return M1([J,Q,Z],(q,K,H)=>{const I=Y1(q);return I.forEach(($)=>{$?.addEventListener(K,G,H)}),()=>{I.forEach(($)=>{$?.removeEventListener(K,G,H)})}})},{sync:"init"})},E4=W3;var $3=(J=[])=>{J=Y1(J);const Q=new AbortController,X=Q.abort.bind(Q);if(J.some((G)=>G.aborted))X();else J.forEach((G)=>E4(G,"abort",X)),q1(X);return Q},k4=$3;var w3=(J=[])=>{return k4(J).signal},S4=w3;var y4=H2;var F3=({loop:J,once:Q,callback:X,cancel:Z,schedule:G})=>{let q=!1,K=y4(),H;const I=(W)=>{if(q=!0,M(J))$();M(X,!1)(W)},$=()=>{H=v(()=>G(I))},z=()=>{v(()=>Z(H))};return B1(()=>{if(Q&&q)return;if(K())return;return $(),z},{suspense:!1}),z},e=F3;var V3=(J)=>{return e({callback:J,once:!0,cancel:cancelAnimationFrame,schedule:requestAnimationFrame})},d9=V3;var U3=(J)=>{return e({callback:J,loop:!0,cancel:cancelAnimationFrame,schedule:requestAnimationFrame})},u9=U3;var m4=_1;var z3=function(J){const{symbol:Q,defaultValue:X}=O0.get(J)||{symbol:Symbol()},Z=S(Q);return b(Z)?X:Z},s9=z3;var JX=J2;var u=H0;var h4={create:()=>{const J=u(0),G={active:m(()=>!!J()),increment:(K=1)=>J((H)=>H+K),decrement:(K=-1)=>queueMicrotask(()=>J((H)=>H+K))},q=S(U0);if(q)q?.register(G),q1(()=>q.unregister(G));return G},get:()=>{return S(w2)},wrap:(J)=>{const Q=h4.create();return S({[w2]:Q},()=>{return N(()=>J(Q))})}},k0=h4;class b4{suspenses=new Map;change=(J,Q)=>{const X=this.suspenses.get(J)||0,Z=Math.max(0,X+Q);if(X===Z)return;if(Z)this.suspenses.set(J,Z);else this.suspenses.delete(J);if(Q>0)J.increment(Q);else J.decrement(Q)};suspend=()=>{const J=k0.get();if(!J)return;this.change(J,1),q1(()=>{this.change(J,-1)})};unsuspend=()=>{this.suspenses.forEach((J,Q)=>{this.change(Q,-J)})}}var p4=b4;var d4=Z2;var D3={sync:"init"},T3=(J)=>{return B1(J,D3)},g=T3;var Y3=(J)=>{const Q=u(!0),X=u(),Z=u(),G=u(),{suspend:q,unsuspend:K}=new p4,H={pending:!0,get value(){return void q()},get latest(){return G()??void q()}},I={pending:!1,get error(){return X()},get value(){throw X()},get latest(){throw X()}},$={pending:!1,get value(){return Z()},get latest(){return Z()}},z={pending:()=>Q(),error:()=>X(),value:()=>W().value,latest:()=>W().latest},W=u(H);return g(()=>{const U=S0(),D=()=>{Q(!0),X(void 0),Z(void 0),W(H)},F=(Y)=>{if(U())return;Q(!1),X(void 0),Z(()=>Y),G(()=>Y),W($)},V=(Y)=>{if(U())return;Q(!1),X(x4(Y)),Z(void 0),G(void 0),W(I)},w=()=>{if(U())return;K()};(()=>{try{const Y=M(J());if(L4(Y))D(),Y.then(F,V).finally(w);else F(Y),w()}catch(Y){V(Y),w()}})()}),t(d4(W),z)},m1=Y3;var M3=(J,Q)=>{return m1(()=>{return M1([J,Q],(X,Z={})=>{const G=S4(Z.signal||[]);return Z.signal=G,fetch(X,Z)})})},RX=M3;var x3=(J,Q)=>{return e({callback:J,once:!0,cancel:cancelIdleCallback,schedule:(X)=>requestIdleCallback(X,M(Q))})},_X=x3;var P3=(J,Q)=>{return e({callback:J,loop:!0,cancel:cancelIdleCallback,schedule:(X)=>requestIdleCallback(X,M(Q))})},yX=P3;var C3=(J,Q)=>{return e({callback:J,cancel:clearInterval,schedule:(X)=>setInterval(X,M(Q))})},pX=C3;var j3=(J)=>{return m1(()=>M(J))},uX=j3;var t1=G2;var rX=q2;var A3=(J,Q)=>{return e({callback:J,once:!0,cancel:clearTimeout,schedule:(X)=>setTimeout(X,M(Q))})},eX=A3;var y0=$2;var N3=()=>{let J=!1;const Q=()=>J;return q1(()=>J=!0),Q},S0=N3;var B3=(J)=>{const Q=S0(),X=F0();queueMicrotask(()=>{if(Q())return;X(J)})},V2=B3;var m0=d;var h0=K2;var i4=(J,Q,X)=>{const{className:Z}=J;if(p(Z)){if(!Z)if(X){J.className=Q;return}else return;else if(!X&&Z===Q){J.className="";return}}if(Q.includes(" "))Q.split(" ").forEach((G)=>{if(!G.length)return;J.classList.toggle(G,!!X)});else J.classList.toggle(Q,!!X)};var b0=document.createComment(""),U2=[b0],z2=[b0],L3=(J,Q,X,Z)=>{if(Q===X)return;if(Q instanceof Node){if(X instanceof Node){if(Q.parentNode===J){J.replaceChild(X,Q);return}}U2[0]=Q,Q=U2}if(X instanceof Node)z2[0]=X,X=z2;const G=X.length;let q=Q.length,K=G,H=0,I=0,$=null,z;while(H<q||I<K)if(q===H){const W=K<G?I?X[I-1].nextSibling:X[K-I]:Z;if(I<K){if(W)W.before.apply(W,X.slice(I,K));else J.append.apply(J,X.slice(I,K));I=K}}else if(K===I)while(H<q){if(!$||!$.has(Q[H])){if(z=Q[H],z.parentNode===J)J.removeChild(z)}H++}else if(Q[H]===X[I])H++,I++;else if(Q[q-1]===X[K-1])q--,K--;else if(Q[H]===X[K-1]&&X[I]===Q[q-1]){const W=Q[--q].nextSibling;J.insertBefore(X[I++],Q[H++].nextSibling),J.insertBefore(X[--K],W),Q[q]=X[K]}else{if(!$){$=new Map;let W=I;while(W<K)$.set(X[W],W++)}if($.has(Q[H])){const W=$.get(Q[H]);if(I<W&&W<K){let U=H,D=1;while(++U<q&&U<K&&$.get(Q[U])===W+D)D++;if(D>W-I){const F=Q[H];if(I<W){if(F)F.before.apply(F,X.slice(I,W));else J.append.apply(J,X.slice(I,W));I=W}}else J.replaceChild(X[I++],Q[H++])}else H++}else if(z=Q[H++],z.parentNode===J)J.removeChild(z)}U2[0]=b0,z2[0]=b0},v4=L3;var R3=[],h1={make:()=>{return{values:void 0,length:0}},makeWithNode:(J)=>{return{values:J,length:1}},makeWithFragment:(J)=>{return{values:J,fragmented:!0,length:1}},getChildrenFragmented:(J,Q=[])=>{const{values:X,length:Z}=J;if(!Z)return Q;if(X instanceof Array)for(let G=0,q=X.length;G<q;G++){const K=X[G];if(K instanceof Node)Q.push(K);else h1.getChildrenFragmented(K,Q)}else if(X instanceof Node)Q.push(X);else h1.getChildrenFragmented(X,Q);return Q},getChildren:(J)=>{if(!J.length)return R3;if(!J.fragmented)return J.values;if(J.length===1)return h1.getChildren(J.values);return h1.getChildrenFragmented(J)},pushFragment:(J,Q)=>{h1.pushValue(J,Q),J.fragmented=!0},pushNode:(J,Q)=>{h1.pushValue(J,Q)},pushValue:(J,Q)=>{const{values:X,length:Z}=J;if(Z===0)J.values=Q;else if(Z===1)J.values=[X,Q];else X.push(Q);J.length+=1},replaceWithNode:(J,Q)=>{J.values=Q,delete J.fragmented,J.length=1},replaceWithFragment:(J,Q)=>{J.values=Q.values,J.fragmented=Q.fragmented,J.length=Q.length}},_=h1;var z0=(J,Q,X=!1)=>{if(P(J))if(!N1(J))z0(J(),Q,X);else g(()=>{z0(J(),Q,!0)});else if(h(J)){const[Z,G]=f3(J);Z[J1]=J[J1],Q(Z,G||X)}else Q(J,X)},p0=(J,Q={})=>{if(p(J))J.split(/\s+/g).filter(Boolean).filter((X)=>{Q[X]=!0});else if(P(J))p0(J(),Q);else if(h(J))J.forEach((X)=>{p0(X,Q)});else if(J)for(let X in J){const Z=J[X];if(!M(Z))continue;Q[X]=!0}return Q},d0=(J,Q={})=>{if(p(J))return J;else if(P(J))return d0(J(),Q);else if(h(J))J.forEach((X)=>{d0(X,Q)});else if(J)for(let X in J){const Z=J[X];Q[X]=M(Z)}return Q},f3=(()=>{const J=[],Q=(X,Z,G)=>{for(let q=0,K=X.length;q<K;q++){const H=X[q],I=typeof H;if(I==="string"||I==="number"||I==="bigint"){if(Z===J)Z=X.slice(0,q);Z.push(S1(H))}else if(I==="object"&&h(H)){if(Z===J)Z=X.slice(0,q);G=Q(H,Z,G)[1]}else if(I==="function"&&s1(H)){if(Z!==J)Z.push(H);G=!0}else if(Z!==J)Z.push(H)}if(Z===J)Z=X;return[Z,G]};return(X)=>{return Q(X,J,!1)}})();var i0=(()=>{const J=new Set(["allowfullscreen","async","autofocus","autoplay","checked","controls","default","disabled","formnovalidate","hidden","indeterminate","ismap","loop","multiple","muted","nomodule","novalidate","open","playsinline","readonly","required","reversed","seamless","selected"]),Q=/e(r[HRWrv]|[Vawy])|Con|l(e[Tcs]|c)|s(eP|y)|a(t[rt]|u|v)|Of|Ex|f[XYa]|gt|hR|d[Pg]|t[TXYd]|[UZq]/,X={},Z=/[A-Z]/g,G=(q)=>{return X[q]||(X[q]=Q.test(q)?q:q.replace(Z,(K)=>`-${K.toLowerCase()}`))};return(q,K,H)=>{if(y1(q))if(K=K==="xlinkHref"||K==="xlink:href"?"href":G(K),b(H)||H===!1&&J.has(K))q.removeAttribute(K);else q.setAttribute(K,String(H));else if(b(H)||H===!1&&J.has(K))q.removeAttribute(K);else H=H===!0?"":String(H),q.setAttribute(K,H)}})(),M2=(J,Q,X)=>{if(P(X)&&N1(X))g(()=>{i0(J,Q,X())});else i0(J,Q,M(X))},O3=(J,Q,X)=>{g(()=>{let Z=X();while(P(Z))Z=Z();x2(J,Q,!1,Z,!0)})},r4=(J,Q)=>{if(Q.nodeType===3)return Q.nodeValue=J,Q;else{const X=Q.parentElement;if(!X)throw new Error("Invalid child replacement");const Z=S1(J);return X.replaceChild(Z,Q),Z}},a4=(J,Q)=>{const X=typeof J;if(X==="string"||X==="number"||X==="bigint")r4(String(J),Q);else{const Z=Q.parentElement;if(!Z)throw new Error("Invalid child replacement");const G=_.makeWithNode(Q);if(X==="function")O3(Z,G,J);else u0(Z,J,G)}},x2=(J,Q,X,Z,G)=>{if(!G&&Z===void 0)return;const q=_.getChildren(Q),K=q instanceof Array,H=K?q.length:1,I=K?q[0]:q,z=(K?q[H-1]:q)?.nextSibling||null;if(H===0){const V=typeof Z;if(V==="string"||V==="number"||V==="bigint"){const w=S1(Z);if(!X)J.appendChild(w);_.replaceWithNode(Q,w);return}else if(V==="object"&&Z!==null&&typeof Z.nodeType==="number"){const w=Z;if(!X)J.insertBefore(w,null);_.replaceWithNode(Q,w);return}}if(H===1&&I.parentNode){const V=typeof Z;if(V==="string"||V==="number"||V==="bigint"){const w=r4(String(Z),I);_.replaceWithNode(Q,w);return}}const W=_.make(),U=Array.isArray(Z)?Z:[Z];for(let V=0,w=U.length;V<w;V++){const T=U[V],Y=typeof T;if(Y==="string"||Y==="number"||Y==="bigint")_.pushNode(W,S1(T));else if(Y==="object"&&T!==null&&typeof T.nodeType==="number")_.pushNode(W,T);else if(Y==="function"){const C=_.make();let A=!X;_.pushFragment(W,C),z0(T,(B,c)=>{const l=A;A=!1,x2(J,C,l,B,c)})}}let D=_.getChildren(W),F=W.length;if(F===0&&H===1&&I.nodeType===8)return;if(!X&&(F===0||H===1&&I.nodeType===8||U[J1])){const{childNodes:V}=J;if(V.length===H){if(J.textContent="",F===0){const w=W.placeholder||=Q.placeholder||=F2();if(_.pushNode(W,w),D!==W.values)D=w,F+=1}if(z)if(D instanceof Array)z.before.apply(z,D);else J.insertBefore(D,z);else if(D instanceof Array)J.append.apply(J,D);else J.append(D);_.replaceWithFragment(Q,W);return}}if(F===0){const V=W.placeholder||=Q.placeholder||=F2();if(_.pushNode(W,V),D!==W.values)D=V,F+=1}if(!X)v4(J,q,D,z);_.replaceWithFragment(Q,W)},u0=(J,Q,X=_.make())=>{z0(Q,x2.bind(void 0,J,X,!1))},v0=i4,D2=(J,Q,X)=>{if(P(X)&&N1(X))g(()=>{v0(J,Q,X())});else v0(J,Q,M(X))},u4=(J,Q,X,Z)=>{if(Z&&Z!==!0)v0(J,Z,!1);if(X&&X!==!0)v0(J,X,Q)},T2=(J,Q,X)=>{if(P(X)&&N1(X)){let Z;g(()=>{const G=X();u4(J,Q,G,Z),Z=G})}else u4(J,Q,M(X))},c4=(J,Q,X)=>{if(p(Q))if(y1(J))J.setAttribute("class",Q);else J.className=Q;else{if(X)if(p(X)){if(X)if(y1(J))J.setAttribute("class","");else J.className=""}else if(h(X)){X=h0.unwrap(X);for(let Z=0,G=X.length;Z<G;Z++){if(!X[Z])continue;T2(J,!1,X[Z])}}else{X=h0.unwrap(X);for(let Z in X){if(Q&&Z in Q)continue;D2(J,Z,!1)}}if(h(Q))if(m0(Q))for(let Z=0,G=Q.length;Z<G;Z++){const q=v(()=>P(Q[Z])?Q[Z]:Q[C1](String(Z)));T2(J,!0,q)}else for(let Z=0,G=Q.length;Z<G;Z++){if(!Q[Z])continue;T2(J,!0,Q[Z])}else if(m0(Q))for(let Z in Q){const G=v(()=>P(Q[Z])?Q[Z]:Q[C1](Z));D2(J,Z,G)}else for(let Z in Q)D2(J,Z,Q[Z])}},P2=(J,Q)=>{if(P(Q)||h(Q)){let X;g(()=>{const Z=p0(Q);c4(J,Z,X),X=Z})}else c4(J,Q)},g3=(J,Q,X)=>{const Z=_0[Q]||Symbol(),G=S(Z)||V0[Z];if(!G)throw new Error(`Directive "${Q}" not found`);const q=()=>G.fn(J,...Y1(X));if(G.immediate)q();else V2(q)},_3=(()=>{const J={onauxclick:["_onauxclick",!1],onbeforeinput:["_onbeforeinput",!1],onclick:["_onclick",!1],ondblclick:["_ondblclick",!1],onfocusin:["_onfocusin",!1],onfocusout:["_onfocusout",!1],oninput:["_oninput",!1],onkeydown:["_onkeydown",!1],onkeyup:["_onkeyup",!1],onmousedown:["_onmousedown",!1],onmouseup:["_onmouseup",!1]},Q=(X)=>{const Z=`_${X}`;document.addEventListener(X.slice(2),(G)=>{const q=G.composedPath();let K=null;Object.defineProperty(G,"currentTarget",{configurable:!0,get(){return K}});for(let H=0,I=q.length;H<I;H++){K=q[H];const $=K[Z];if(!$)continue;if($(G),G.cancelBubble)break}K=null})};return(X,Z,G)=>{if(Z.startsWith("onmiddleclick")){const K=G;Z=`onauxclick${Z.slice(13)}`,G=K&&((H)=>H.button===1&&K(H))}const q=J[Z];if(q){if(!q[1])q[1]=!0,Q(Z);X[q[0]]=G}else if(Z.endsWith("passive")){const K=Z.endsWith("capturepassive"),H=Z.slice(2,-7-(K?7:0)),I=`_${Z}`,$=X[I];if($)X.removeEventListener(H,$,{capture:K});if(G)X.addEventListener(H,G,{passive:!0,capture:K});X[I]=G}else if(Z.endsWith("capture")){const K=Z.slice(2,-7),H=`_${Z}`,I=X[H];if(I)X.removeEventListener(K,I,{capture:!0});if(G)X.addEventListener(K,G,{capture:!0});X[H]=G}else X[Z]=G}})(),C2=(J,Q,X)=>{_3(J,Q,X)},E3=(J,Q)=>{J.innerHTML=String(b(Q)?"":Q)},j2=(J,Q)=>{g(()=>{E3(J,M(M(Q).__html))})},n4=(J,Q,X)=>{if(Q==="tabIndex"&&j4(X))X=X?0:void 0;if(Q==="value"){if(J.tagName==="PROGRESS")X??=null;else if(J.tagName==="SELECT"&&!J._$inited)J._$inited=!0,queueMicrotask(()=>J[Q]=X)}try{if(J[Q]=X,b(X))i0(J,Q,null)}catch{i0(J,Q,X)}},A2=(J,Q,X)=>{if(P(X)&&N1(X))g(()=>{n4(J,Q,X())});else n4(J,Q,M(X))},N2=(J,Q)=>{if(b(Q))return;const X=P4(Y1(Q)).filter(Boolean);if(!X.length)return;V2(()=>v(()=>X.forEach((Z)=>Z?.(J))))},Y2=(()=>{const J=/^(-|f[lo].*[^se]$|g.{5,}[^ps]$|z|o[pr]|(W.{5})?[lL]i.*(t|mp)$|an|(bo|s).{4}Im|sca|m.{6}[ds]|ta|c.*[st]$|wido|ini)/i,Q={};return(X,Z,G)=>{if(Z.charCodeAt(0)===45)if(b(G))X.style.removeProperty(Z);else X.style.setProperty(Z,String(G));else if(b(G))X.style[Z]=null;else X.style[Z]=p(G)||(Q[Z]||=J.test(Z))?G:`${G}px`}})(),o4=(J,Q,X)=>{if(P(X)&&N1(X))g(()=>{Y2(J,Q,X())});else Y2(J,Q,M(X))},l4=(J,Q,X)=>{if(p(Q))J.setAttribute("style",Q);else{if(X)if(p(X)){if(X)J.style.cssText=""}else{X=h0.unwrap(X);for(let Z in X){if(Q&&Z in Q)continue;Y2(J,Z,null)}}if(m0(Q))for(let Z in Q){const G=v(()=>P(Q[Z])?Q[Z]:Q[C1](Z));o4(J,Z,G)}else for(let Z in Q)o4(J,Z,Q[Z])}},B2=(J,Q)=>{if(P(Q)||h(Q)){let X;g(()=>{const Z=d0(Q);l4(J,Z,X),X=Z})}else l4(J,M(Q))},k3=(J,Q,X)=>{if(Q==="children"){const Z=S1("");J.insertBefore(Z,null),X(J,"setChildReplacement",void 0,Z)}else if(Q==="ref")X(J,"setRef");else if(Q==="style")X(J,"setStyles");else if(Q==="class"){if(!y1(J))J.className="";X(J,"setClasses")}else if(Q==="dangerouslySetInnerHTML")X(J,"setHTML");else if(Q.charCodeAt(0)===111&&Q.charCodeAt(1)===110)X(J,"setEvent",Q.toLowerCase());else if(Q.charCodeAt(0)===117&&Q.charCodeAt(3)===58)X(J,"setDirective",Q.slice(4));else if(Q==="innerHTML"||Q==="outerHTML"||Q==="textContent"||Q==="className");else if(Q in J&&!y1(J))X(J,"setProperty",Q);else J.setAttribute(Q,""),X(J,"setAttribute",Q)},S3=(J,Q,X)=>{if(X===void 0)return;if(f4(X))k3(J,Q,X);else if(Q==="children")u0(J,X);else if(Q==="ref")N2(J,X);else if(Q==="style")B2(J,X);else if(Q==="class")P2(J,X);else if(Q==="dangerouslySetInnerHTML")j2(J,X);else if(Q.charCodeAt(0)===111&&Q.charCodeAt(1)===110)C2(J,Q.toLowerCase(),X);else if(Q.charCodeAt(0)===117&&Q.charCodeAt(3)===58)g3(J,Q.slice(4),X);else if(Q==="innerHTML"||Q==="outerHTML"||Q==="textContent"||Q==="className");else if(Q in J&&!y1(J))A2(J,Q,X);else M2(J,Q,X)},s4=(J,Q)=>{for(let X in Q)S3(J,X,Q[X])};var y3=(J,Q,...X)=>{const{children:Z,key:G,ref:q,...K}=Q||{},H=X.length===1?X[0]:X.length===0?Z:X;if(P(J)){const I=K;if(!b(H))I.children=H;if(!b(q))I.ref=q;return a1(()=>{return v(()=>J.call(J,I))})}else if(p(J)){const I=K,$=R4(J),z=$?M4:E0;if(!g4(H))I.children=H;if(!b(q))I.ref=q;return a1(()=>{const W=z(J);if($)W.isSVG=!0;return v(()=>s4(W,I)),W})}else if(N4(J))return a1(()=>J);else throw new Error("Invalid component")},K1=y3;var n=N;var m3=({component:J,props:Q,children:X})=>{return m(()=>{return n(K1(M(J,!1),M(Q),X))})},JG=m3;var h3=({fallback:J,children:Q})=>{return W2(Q,(X)=>v(()=>P(J)?J(X):J))},qG=h3;var b3=function({values:J,fallback:Q,pooled:X,unkeyed:Z,children:G}){return Q2(J,G,Q,{pooled:X,unkeyed:Z})},IG=b3;var p3=({children:J})=>{return J},$G=p3;var d3=(J,Q)=>{let X;const Z=m(()=>{const G=M(J);if(!Q(G))return X;return X=G});return()=>{const G=Z();if(b(G))throw new Error("The value never passed the type guard");return G}},t4=d3;var i3=({when:J,fallback:Q,children:X})=>{if(P(X)&&!s1(X)&&!A4(X)){const Z=t4(J,O4);return j1(J,y0(()=>X(Z)),Q)}else return j1(J,X,Q)},PG=i3;var c0=G0;var e4={},v3=F0(),u3=1,c3=({id:J,ttl:Q,children:X})=>{return m(()=>{return M1([J,Q],(Z,G)=>{const q=u3++,K=e4[Z]||={id:Z,lock:q};if(K.lock=q,K.reset?.(),K.suspended||=u(!1),K.suspended(!1),!K.dispose||!K.result)v3(()=>{t1((H)=>{K.dispose=()=>{delete e4[Z],H()},c0(K.suspended,()=>{K.result=n(X)})})});return q1(()=>{const H=()=>q===K.lock;if(!H())return;if(K.suspended?.(!0),!G||G<=0||G>=Infinity)return;const $=setTimeout(()=>H()&&K.dispose?.(),G),z=()=>clearTimeout($);K.reset=z}),K.result})})},EG=c3;var n3=(J,Q)=>{if(!Q||!(Q instanceof HTMLElement))throw new Error("Invalid parent node");return Q.textContent="",t1((X)=>{return u0(Q,y0(J)),()=>{X(),Q.textContent=""}})},J5=n3;var o3=({when:J=!0,mount:Q,wrapper:X,children:Z})=>{const G=M(X)||E0("div");if(!(G instanceof HTMLElement))throw new Error("Invalid wrapper node");const q=m4(J);return g(()=>{if(!M(q))return;const K=M(Q)||document.body;if(!(K instanceof Element))throw new Error("Invalid mount node");return K.insertBefore(G,null),()=>{K.removeChild(G)}}),g(()=>{if(!M(q))return;return J5(Z,G)}),t(()=>M(q)||Z,{metadata:{portal:G}})},Q5=o3;var l3=({when:J,fallback:Q,children:X})=>{return k0.wrap((Z)=>{const G=m(()=>!!M(J)||Z.active()),q=c0(G,()=>n(X));return j1(G,Q,q)})},eG=l3;var L2=({when:J,fallback:Q,children:X})=>{const G=Y1(X).map((q)=>q().metadata);return q0(J,G,Q)};L2.Case=({when:J,children:Q})=>{return t(()=>Q,{metadata:[J,Q]})};L2.Default=({children:J})=>{return t(()=>J,{metadata:[J]})};var Zq=L2;var r3=({when:J,children:Q})=>{return j1(J,Q[0],Q[1])},Kq=r3;var Iq=(J,Q)=>{return K1(J,Q)};var Fq=t0;var a3=function(J){const Q=Symbol(),Z={Provider:({value:G,children:q})=>{return S({[Q]:G},()=>{return n(q)})}};return O0.set(Z,{symbol:Q,defaultValue:J}),Z},Tq=a3;var s3=(J,Q,X)=>{const Z=!!X?.immediate,G={fn:Q,immediate:Z},q=_0[J]||=Symbol();return{Provider:({children:$})=>{return S({[q]:G},()=>{return n($)})},ref:(...$)=>{return(z)=>{Q(z,...$)}},register:()=>{if(q in V0)throw new Error('Directive "name" is already registered');V0[q]=G}}},Cq=s3;var t3=function(J,Q,...X){if(X.length||B4(Q)&&!h(Q))return K1(J,Q,...X);else return K1(J,null,Q)},Bq=t3;var e3=/^_?[A-Z][a-zA-Z0-9$_-]*$/,J6="__hmr_as__",R2=Symbol("HMR.Cold"),D0=Symbol("HMR.Hot"),X5=Symbol("HMR.ID"),f2=new WeakMap,Q6=(J,Q)=>{if(J){const X=Q[D0];if(X)return X;if(!P(Q)&&"Provider"in Q)return Q;const G=(W)=>{return(...U)=>{return m(()=>{const D=W.reduce((V,w)=>V[w],f2.get(H())?.()||I());return n(v(()=>D(...U)))})}},q=(W,U)=>{const D=W[D0];if(D)return D;const F=W[D0]=G(U);for(let V in W){const w=W[V];if(P(w)&&e3.test(V))F[V]=q(w,[...U,V]);else F[V]=w}return F},K=(W)=>{const U=W[Q[J6]]||W[Q.name]||W.default;if(!U)return console.error(`[hmr] Failed to handle update for "${Q.name}" component:\n\n`,Q);const D=U[R2]||U;U[X5]?.(H()),f2.get(H())?.(()=>D)},H=u({}),I=u(Q);f2.set(H(),I);const $=Q[R2]||Q,z=q(Q,[]);return $[D0]=z,z[R2]=$,z[D0]=z,z[X5]=H,J(K),z}else return Q},Eq=Q6;var G5=function(J,Q,X,Z){var G;Q[0]=0;for(var q=1;q<Q.length;q++){var K=Q[q++],H=Q[q]?(Q[0]|=K?1:2,X[Q[q++]]):Q[++q];K===3?Z[0]=H:K===4?Z[1]=Object.assign(Z[1]||{},H):K===5?(Z[1]=Z[1]||{})[Q[++q]]=H:K===6?Z[1][Q[++q]]+=H+"":K?(G=J.apply(H,G5(J,H,X,["",null])),Z.push(G),H[0]?Q[0]|=2:(Q[q-2]=0,Q[q]=G)):Z.push(H)}return Z},Z5=new Map;function O2(J){var Q=Z5.get(this);return Q||(Q=new Map,Z5.set(this,Q)),(Q=G5(this,Q.get(J)||(Q.set(J,Q=function(X){for(var Z,G,q=1,K="",H="",I=[0],$=function(U){q===1&&(U||(K=K.replace(/^\s*\n\s*|\s*\n\s*$/g,"")))?I.push(0,U,K):q===3&&(U||K)?(I.push(3,U,K),q=2):q===2&&K==="..."&&U?I.push(4,U,0):q===2&&K&&!U?I.push(5,0,!0,K):q>=5&&((K||!U&&q===5)&&(I.push(q,0,K,G),q=6),U&&(I.push(q,U,0,G),q=6)),K=""},z=0;z<X.length;z++){z&&(q===1&&$(),$(z));for(var W=0;W<X[z].length;W++)Z=X[z][W],q===1?Z==="<"?($(),I=[I],q=3):K+=Z:q===4?K==="--"&&Z===">"?(q=1,K=""):K=Z+K[0]:H?Z===H?H="":K+=Z:Z==='"'||Z==="'"?H=Z:Z===">"?($(),q=1):q&&(Z==="="?(q=5,G=K,K=""):Z==="/"&&(q<5||X[z][W+1]===">")?($(),q===3&&(I=I[0]),q=I,(I=I[0]).push(2,0,q),q=0):Z===" "||Z==="\t"||Z==="\n"||Z==="\r"?($(),q=2):K+=Z),q===3&&K==="!--"&&(q=4,I=I[0])}return $(),I}(J)),Q),arguments,[])).length>1?Q:Q[0]}var q5={},X6=(J,Q,...X)=>K1(q5[J]||J,Q,...X),Z6=(J)=>void t(q5,J),G6=t(O2.bind(X6),{register:Z6}),bq=G6;var iq=K0;var q6=(J)=>{const Q=_4(J),X=(Z)=>{const G=m1(Q);return m(()=>{return M1(G,({pending:q,error:K,value:H})=>{if(q)return;if(K)throw K;const I="default"in H?H.default:H;return n(K1(I,Z))})})};return X.preload=()=>{return new Promise((Z,G)=>{const q=m1(Q);M1(q,({pending:K,error:H})=>{if(K)return;if(H)return G(H);return Z()})})},X},aq=q6;var g2={create:()=>{const J=g2.get(),Q=u([]),X=m(()=>Q().some((K)=>K.active()));return{suspenses:Q,active:X,register:(K)=>{J?.register(K),Q((H)=>[...H,K])},unregister:(K)=>{J?.unregister(K),Q((H)=>H.filter((I)=>I!==K))}}},get:()=>{return S(U0)},wrap:(J)=>{const Q=g2.create();return S({[U0]:Q},()=>{return N(()=>J(Q))})}},K5=g2;var K6=(J)=>{return new Promise((Q)=>{t1((X)=>{M(K5.wrap((Z)=>{const{portal:G}=Q5({children:J}).metadata;B1(()=>{if(Z.active())return;Q(G.innerHTML),X()},{suspense:!1})}))})})},IK=K6;var H6=(J)=>{const Q=/^[a-z0-9-_]+$/i,X=(F)=>{if(p(F)&&Q.test(F))return!0;throw new Error(`Invalid property, only alphanumeric properties are allowed inside templates, received: "${F}"`)},Z=(F)=>{return new Proxy({},{get(V,w){X(w);const T=(C,A,B,c)=>{if(B)X(B);F.push([C,A,w,B,c])},Y={[g0]:!0};return t(T,Y)}})},G=()=>{const F=[],V=Z(F),w=J(V);if(P(w)){const T=w();if(T instanceof Element)return{actionsWithNodes:F,root:T}}throw new Error("Invalid template, it must return a function that returns an Element")},q=(F)=>{const V=[];for(let w=0,T=F.length;w<T;w++){const[Y,C,A,B,c]=F[w],l=K(Y),T0=c?K(c):void 0;V.push([l,C,A,B,T0])}return V},K=(()=>{let F=null,V;return(w)=>{if(w===F)return V;const T=[];let Y=w,C=Y.parentNode;while(C){const A=!Y.previousSibling?0:!Y.nextSibling?-0:C4(C.childNodes,Y);T.push(A),Y=C,C=C.parentNode}return F=w,V=T,T}})(),H=(F)=>{const V=["root"],w=F.slice().reverse();for(let T=0,Y=w.length;T<Y;T++){const C=w[T];if(Object.is(0,C))V.push("firstChild");else if(Object.is(-0,C))V.push("lastChild");else{V.push("firstChild");for(let A=0;A<C;A++)V.push("nextSibling")}}return V},I=(F)=>{const V=[];for(let w=0,T=F.length;w<T;w++){const Y=F[w],C=Y[0],A=Y[4];if(V.push(C),A)V.push(A)}return V},$=(F,V)=>{const w=new Array(F.length);for(let T=0,Y=F.length;T<Y;T++)w[T]={path:F[T],properties:V[T]};return w},z=(F)=>{const V=I(F),w=V.map(H),T=$(V,w),Y=[],C=new Map;let A=0;while(!0){const B=T.find((e1)=>e1.properties.length>1);if(!B)break;const[c,l]=B.properties,T0=`\$${A++}`,H5=`const ${T0} = ${c}.${l};`;Y.push(H5);for(let e1=0,I5=T.length;e1<I5;e1++){const n0=T[e1],[W5,$5]=n0.properties;if(W5!==c||$5!==l)continue;n0.properties[0]=T0,n0.properties.splice(1,1)}}for(let B=0,c=T.length;B<c;B++){const l=T[B];C.set(l.path,l.properties[0])}return{assignments:Y,map:C}},W=(F,V)=>{const w=[];for(let T=0,Y=F.length;T<Y;T++){const[C,A,B,c,l]=F[T];if(l)w.push(`this.${A} ( props["${B}"], ${V.get(l)} );`);else if(c)w.push(`this.${A} ( ${V.get(C)}, "${c}", props["${B}"] );`);else w.push(`this.${A} ( ${V.get(C)}, props["${B}"] );`)}return w},U=(F)=>{const{assignments:V,map:w}=z(F),T=W(F,w),Y=new Function("root","props",`${V.join("")}${T.join("")}return root;`),C={setAttribute:M2,setChildReplacement:a4,setClasses:P2,setEvent:C2,setHTML:j2,setProperty:A2,setRef:N2,setStyles:B2};return Y.bind(C)};return(()=>{const{actionsWithNodes:F,root:V}=G(),w=q(F),T=U(w);return(Y)=>{const C=V.cloneNode(!0);return a1(T.bind(void 0,C,Y))}})()},UK=H6;var TK=I2;export{y0 as useUntracked,eX as useTimeout,y4 as useSuspended,rX as useSelector,t1 as useRoot,m1 as useResource,M1 as useResolved,d4 as useReadonly,uX as usePromise,V2 as useMicrotask,m as useMemo,pX as useInterval,yX as useIdleLoop,_X as useIdleCallback,RX as useFetch,E4 as useEventListener,B1 as useEffect,JX as useDisposed,s9 as useContext,q1 as useCleanup,m4 as useBoolean,u9 as useAnimationLoop,d9 as useAnimationFrame,S4 as useAbortSignal,k4 as useAbortController,v as untrack,TK as tick,UK as template,h0 as store,n as resolve,IK as renderToString,J5 as render,aq as lazy,Iq as jsxs,Iq as jsxDEV,Iq as jsx,m0 as isStore,W6 as isServer,s1 as isObservable,iq as isBatching,bq as html,Eq as hmr,Bq as h,K1 as createElement,Cq as createDirective,Tq as createContext,Fq as batch,Kq as Ternary,Zq as Switch,eG as Suspense,Q5 as Portal,EG as KeepAlive,PG as If,$G as Fragment,IG as For,qG as ErrorBoundary,JG as Dynamic,M as $$,u as $};
